/*
 * Copyright (c) 2011, 2012  Timo Savola
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 */

#ifdef CONCRETE_TRACE

#include "trace.hpp"

#include <cstdint>

#include <boost/static_assert.hpp>

#include <concrete/allocation.hpp>
#include <concrete/arena.hpp>
#include <concrete/byteorder.hpp>
#include <concrete/pointer.hpp>
#include <concrete/util/assert.hpp>

namespace concrete {

void TraceData(const void *void_data, size_t size) throw ()
{
	assert(void_data);

	const uint32_t *word_data = reinterpret_cast<const uint32_t *> (void_data);
	BOOST_STATIC_ASSERT(Allocator::Alignment >= sizeof (word_data[0]));
	unsigned int word_count = Allocator::AlignedSize(size) / sizeof (word_data[0]);

	std::string line;

	for (unsigned int i = 0; i < word_count; i++) {
		if ((i & 7) == 0)
			line += boost::str(boost::format("%5u:") % i);

		line += boost::str(boost::format(" %08lx") % PortByteorder(word_data[i]));

		if ((i & 7) == 7) {
			TraceOutput(line);
			line = "";
		}
	}

	if (word_count & 7)
		TraceOutput(line);
}

void TraceData(const Pointer &pointer, size_t size) throw ()
{
	TraceData(Arena::Active().nonthrowing_access(pointer.address(), 0), size);
}

} // namespace

#endif
