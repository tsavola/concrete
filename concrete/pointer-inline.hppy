/*
 * Copyright (c) 2011, 2012  Timo Savola
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 */

#include <concrete/arena.hpp>
#include <concrete/util/assert.hpp>

namespace concrete {

template <typename PointerType>
PointerType Pointer::RawAccess::Materialize(RawType address) throw ()
{
	return PointerType(address);
}

template <typename PointerType>
PointerType Pointer::RawAccess::Materialize(RawType address, PointerType *) throw ()
{
	return PointerType(address);
}

template <typename PointerType, typename... Args>
PointerType Pointer::NewPointer(Args... args)
{
	return NewCustomSizePointer<PointerType>(sizeof (typename PointerType::Data), args...);
}

template <typename PointerType, typename... Args>
PointerType Pointer::NewCustomSizePointer(size_t size, Args... args)
{
	assert(size >= sizeof (typename PointerType::Data));

	auto alloc = Arena::Active().allocate(size);
	new (alloc.data) typename PointerType::Data(args...);

	return PointerType(alloc.address);
}

template <typename PointerType>
void Pointer::DestroyPointer(PointerType &pointer) throw ()
{
	DestroyPointer(pointer, sizeof (typename PointerType::Data));
}

template <typename PointerType>
void Pointer::DestroyPointer(PointerType &pointer, size_t size) throw ()
{
	assert(size >= sizeof (typename PointerType::Data));

	if (pointer.m_address) {
		Arena &arena = Arena::Active();

		void *data = arena.nonthrowing_access(pointer.m_address, size);
		if (data)
			DestroyData(arena, pointer.m_address, static_cast<typename PointerType::Data *> (data), size);

		pointer.reset_address(0);
	}
}

template <typename PointerType>
void Pointer::DestroyPointer(PointerType &pointer, void *data, size_t size) throw ()
{
	assert(size >= sizeof (typename PointerType::Data));

	Arena &arena = Arena::Active();

	if (arena.nonthrowing_extend_access(pointer.m_address, size))
		DestroyData(arena, pointer.m_address, static_cast<typename PointerType::Data *> (data), size);

	pointer.reset_address(0);
}

template <typename DataType>
void Pointer::DestroyData(Arena &arena, unsigned int address, DataType *data, size_t size) throw ()
{
	assert(size >= sizeof (DataType));

	data->~DataType();
	arena.free(address, data, size);
}

template <typename PointerType>
PointerType Pointer::cast() const throw ()
{
	return RawAccess::Materialize<PointerType>(m_address);
}

template <typename DataType>
DataType *Pointer::data_cast() const
{
	return static_cast<DataType *> (Arena::Active().access(m_address, sizeof (DataType)));
}

template <typename DataType>
DataType *Pointer::nonthrowing_data_cast() const throw ()
{
	return static_cast<DataType *> (
		Arena::Active().nonthrowing_access(m_address, sizeof (DataType)));
}

} // namespace
